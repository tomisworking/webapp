name: CD - Main (Deployment)

on:
  workflow_run:
    workflows: 
      - "CI - Main (Security)"
      - "CI - Main (Testy)"
    types:
      - completed
    branches: [ main ]

permissions:
  id-token: write   # Wymagane dla OIDC
  contents: read    # Wymagane do checkout kodu

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY_BACKEND: forum-backend
  S3_BUCKET_FRONTEND: forum-frontend-builds-kongoapp
  ASG_NAME: forum-asg
  LAUNCH_TEMPLATE_NAME: forum-lt
  ALB_DNS: forum-alb-1684129147.us-east-1.elb.amazonaws.com

jobs:
  # ============================================
  # SPRAWD≈π CZY WSZYSTKIE WORKFLOW PRZESZ≈ÅY
  # ============================================
  check-workflows:
    name: Check Security & Tests Status
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success'
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
    
    steps:
      - name: Check if all required workflows passed
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const branch = 'main';
            
            // Pobierz ostatnie uruchomienia workflow
            const securityRuns = await github.rest.actions.listWorkflowRuns({
              owner,
              repo,
              workflow_id: 'main-security.yml',
              branch,
              per_page: 1
            });
            
            const testsRuns = await github.rest.actions.listWorkflowRuns({
              owner,
              repo,
              workflow_id: 'main-tests.yml',
              branch,
              per_page: 1
            });
            
            const securityPassed = securityRuns.data.workflow_runs[0]?.conclusion === 'success';
            const testsPassed = testsRuns.data.workflow_runs[0]?.conclusion === 'success';
            
            console.log(`Security workflow: ${securityPassed ? '‚úÖ passed' : '‚ùå failed'}`);
            console.log(`Tests workflow: ${testsPassed ? '‚úÖ passed' : '‚ùå failed'}`);
            
            if (securityPassed && testsPassed) {
              core.setOutput('should_deploy', 'true');
              console.log('‚úÖ All workflows passed - proceeding with deployment');
            } else {
              core.setOutput('should_deploy', 'false');
              core.setFailed('‚ùå Not all required workflows passed');
            }

  # ============================================
  # BUILD I PUSH DOCKER DO ECR
  # ============================================
  build-and-push-backend:
    name: Build & Push Backend to ECR
    runs-on: ubuntu-latest
    needs: check-workflows
    if: needs.check-workflows.outputs.should_deploy == 'true'
    outputs:
      image_uri: ${{ steps.build-image.outputs.image_uri }}
    
    steps:
      - name: Pobierz kod
        uses: actions/checkout@v3
      
      - name: Konfiguruj AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::311603531332:role/GitHubActionsRole
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Logowanie do Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Build, tag i push obraz do ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY_BACKEND }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          cd backend
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "image_uri=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "‚úÖ Backend image pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

  # ============================================
  # BUILD REACT I UPLOAD DO S3
  # ============================================
  build-and-upload-frontend:
    name: Build & Upload Frontend to S3
    runs-on: ubuntu-latest
    needs: check-workflows
    if: needs.check-workflows.outputs.should_deploy == 'true'
    
    steps:
      - name: Pobierz kod
        uses: actions/checkout@v3
      
      - name: Konfiguruj AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::311603531332:role/GitHubActionsRole
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Ustaw Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Utw√≥rz .env.production
        working-directory: ./frontend
        run: |
          echo "REACT_APP_API_URL=/api" > .env.production
          cat .env.production
      
      - name: Zainstaluj zale≈ºno≈õci
        working-directory: ./frontend
        run: npm ci
      
      - name: Buduj aplikacjƒô React
        working-directory: ./frontend
        run: npm run build
      
      - name: Sprawd≈∫ czy build siƒô uda≈Ç
        working-directory: ./frontend
        run: |
          test -d build && echo "‚úÖ Build successful!" || exit 1
          echo "Build size: $(du -sh build | cut -f1)"
      
      - name: Sprawd≈∫ czy S3 bucket istnieje
        run: |
          if ! aws s3 ls "s3://${{ env.S3_BUCKET_FRONTEND }}" 2>&1 | grep -q 'NoSuchBucket'; then
            echo "‚úÖ Bucket exists"
          else
            echo "‚ö†Ô∏è  Bucket doesn't exist, creating..."
            aws s3 mb "s3://${{ env.S3_BUCKET_FRONTEND }}" --region ${{ env.AWS_REGION }}
            aws s3api put-public-access-block \
              --bucket ${{ env.S3_BUCKET_FRONTEND }} \
              --public-access-block-configuration \
              "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"
          fi
      
      - name: Usu≈Ñ poprzedni build z S3
        run: |
          echo "üóëÔ∏è  Deleting old build from S3..."
          aws s3 rm "s3://${{ env.S3_BUCKET_FRONTEND }}/latest/" --recursive || echo "No old build to delete"
      
      - name: Upload nowy build do S3
        run: |
          echo "üì§ Uploading new build to S3..."
          aws s3 sync frontend/build/ "s3://${{ env.S3_BUCKET_FRONTEND }}/latest/" \
            --delete \
            --region ${{ env.AWS_REGION }} \
            --exclude ".DS_Store" \
            --exclude "*.map"
          echo "‚úÖ Upload completed!"
      
      - name: Utw√≥rz backup (opcjonalne)
        run: |
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          aws s3 sync "s3://${{ env.S3_BUCKET_FRONTEND }}/latest/" "s3://${{ env.S3_BUCKET_FRONTEND }}/backups/$TIMESTAMP/" --region ${{ env.AWS_REGION }} || echo "Backup skipped"
          echo "‚úÖ Backup created: s3://${{ env.S3_BUCKET_FRONTEND }}/backups/$TIMESTAMP/"

  # ============================================
  # UPDATE LAUNCH TEMPLATE (je≈õli potrzeba)
  # ============================================
  update-launch-template:
    name: Update Launch Template
    runs-on: ubuntu-latest
    needs: [check-workflows, build-and-push-backend, build-and-upload-frontend]
    if: needs.check-workflows.outputs.should_deploy == 'true'
    outputs:
      template_updated: ${{ steps.check-changes.outputs.CHANGED }}
    
    steps:
      - name: Pobierz kod
        uses: actions/checkout@v3
      
      - name: Konfiguruj AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::311603531332:role/GitHubActionsRole
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Pobierz Account ID i ECR URI
        id: get-ecr-info
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${{ env.ECR_REPOSITORY_BACKEND }}"
          echo "ECR_URI=$ECR_URI" >> $GITHUB_OUTPUT
          echo "ECR URI: $ECR_URI"
      
      - name: Przygotuj user-data z repo
        id: prepare-user-data
        run: |
          # U≈ºyj user-data z repo
          cp backend/user_data.txt /tmp/user-data.sh
          
          # Podmie≈Ñ dynamiczne warto≈õci
          sed -i "s|311603531332.dkr.ecr.us-east-1.amazonaws.com/forum-backend|${{ steps.get-ecr-info.outputs.ECR_URI }}|g" /tmp/user-data.sh
          
          echo "‚úÖ User-data prepared from repository"
          echo "Preview (first 20 lines):"
          head -20 /tmp/user-data.sh
      
      - name: Sprawd≈∫ czy user-data siƒô zmieni≈Ç
        id: check-changes
        run: |
          # Pobierz obecny user-data z Launch Template
          LATEST_VERSION=$(aws ec2 describe-launch-template-versions \
            --launch-template-name ${{ env.LAUNCH_TEMPLATE_NAME }} \
            --query 'LaunchTemplateVersions[0].VersionNumber' \
            --output text)
          
          aws ec2 describe-launch-template-versions \
            --launch-template-name ${{ env.LAUNCH_TEMPLATE_NAME }} \
            --versions $LATEST_VERSION \
            --query 'LaunchTemplateVersions[0].LaunchTemplateData.UserData' \
            --output text | base64 -d > /tmp/current-user-data.sh
          
          # Por√≥wnaj
          if diff -q /tmp/user-data.sh /tmp/current-user-data.sh > /dev/null 2>&1; then
            echo "CHANGED=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è  User-data unchanged, skipping update"
          else
            echo "CHANGED=true" >> $GITHUB_OUTPUT
            echo "‚úÖ User-data changed, will update"
            echo "Differences:"
            diff /tmp/user-data.sh /tmp/current-user-data.sh || true
          fi
          
          echo "LATEST_VERSION=$LATEST_VERSION" >> $GITHUB_OUTPUT
      
      - name: Utw√≥rz nowƒÖ wersjƒô Launch Template
        if: steps.check-changes.outputs.CHANGED == 'true'
        id: create-version
        run: |
          USER_DATA_B64=$(base64 -w 0 < /tmp/user-data.sh)
          NEW_VERSION=$(aws ec2 create-launch-template-version \
            --launch-template-name ${{ env.LAUNCH_TEMPLATE_NAME }} \
            --source-version ${{ steps.check-changes.outputs.LATEST_VERSION }} \
            --launch-template-data "{\"UserData\":\"$USER_DATA_B64\"}" \
            --query 'LaunchTemplateVersion.VersionNumber' \
            --output text)
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "‚úÖ New Launch Template version created: $NEW_VERSION"
      
      - name: Ustaw nowƒÖ wersjƒô jako domy≈õlnƒÖ
        if: steps.check-changes.outputs.CHANGED == 'true'
        run: |
          aws ec2 modify-launch-template \
            --launch-template-name ${{ env.LAUNCH_TEMPLATE_NAME }} \
            --default-version '$Latest' \
            --region ${{ env.AWS_REGION }}
          echo "‚úÖ New version set as default"

  # ============================================
  # DEPLOY - RESTART ASG
  # ============================================
  deploy:
    name: Deploy to EC2 (ASG Instance Refresh)
    runs-on: ubuntu-latest
    needs: [check-workflows, build-and-push-backend, build-and-upload-frontend, update-launch-template]
    if: needs.check-workflows.outputs.should_deploy == 'true'
    outputs:
      refresh_id: ${{ steps.start-refresh.outputs.REFRESH_ID }}
    
    steps:
      - name: Konfiguruj AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::311603531332:role/GitHubActionsRole
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Anuluj istniejƒÖcy Instance Refresh (je≈õli dzia≈Ça)
        id: cancel-existing
        run: |
          echo "üîç Checking for existing instance refreshes..."
          
          # Pobierz aktywne instance refreshes
          ACTIVE_REFRESHES=$(aws autoscaling describe-instance-refreshes \
            --auto-scaling-group-name ${{ env.ASG_NAME }} \
            --query 'InstanceRefreshes[?Status==`InProgress` || Status==`Pending`].InstanceRefreshId' \
            --output text)
          
          if [ -n "$ACTIVE_REFRESHES" ]; then
            echo "‚ö†Ô∏è  Found active instance refresh(es), cancelling..."
            for REFRESH_ID in $ACTIVE_REFRESHES; do
              echo "Cancelling: $REFRESH_ID"
              aws autoscaling cancel-instance-refresh \
                --auto-scaling-group-name ${{ env.ASG_NAME }} \
                --region ${{ env.AWS_REGION }} || true
            done
            
            # Poczekaj a≈º anulowanie siƒô zako≈Ñczy
            echo "‚è≥ Waiting for cancellation to complete..."
            sleep 30
          else
            echo "‚úÖ No active instance refreshes found"
          fi
      
      - name: Uruchom Instance Refresh
        id: start-refresh
        run: |
          echo "üöÄ Starting instance refresh with correct settings..."
          
          # KLUCZOWE ZMIANY:
          # 1. Strategy = "Rolling" (domy≈õlne, Replace instances)
          # 2. MinHealthyPercentage: 90, MaxHealthyPercentage: 100
          # 3. InstanceWarmup: 300 (5 minut)
          # 4. SkipMatching: true - WA≈ªNE! Wymusza refresh nawet gdy config siƒô nie zmieni≈Ç
          
          REFRESH_ID=$(aws autoscaling start-instance-refresh \
            --auto-scaling-group-name ${{ env.ASG_NAME }} \
            --strategy Rolling \
            --preferences '{
              "MinHealthyPercentage": 90,
              "MaxHealthyPercentage": 100,
              "InstanceWarmup": 300,
              "CheckpointPercentages": [50],
              "CheckpointDelay": 300,
              "SkipMatching": true,
              "ScaleInProtectedInstances": "Ignore",
              "StandbyInstances": "Ignore",
              "AlarmSpecification": {
                "Alarms": []
              }
            }' \
            --region ${{ env.AWS_REGION }} \
            --query 'InstanceRefreshId' \
            --output text 2>&1)
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Failed to start instance refresh!"
            echo "Error: $REFRESH_ID"
            
            # Sprawd≈∫ szczeg√≥≈Çy ASG
            echo "ASG Details:"
            aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names ${{ env.ASG_NAME }} \
              --query 'AutoScalingGroups[0].[MinSize,MaxSize,DesiredCapacity]' \
              --output table
            
            exit 1
          fi
          
          echo "REFRESH_ID=$REFRESH_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Instance refresh started: $REFRESH_ID"
          echo ""
          echo "Settings:"
          echo "  - Strategy: Rolling (Replace instances)"
          echo "  - Min Healthy: 90%"
          echo "  - Max Healthy: 100%"
          echo "  - Instance Warmup: 300s"
          echo "  - Skip Matching: true"
      
      - name: Czekaj na rozpoczƒôcie refresh
        run: |
          echo "‚è≥ Waiting for instance refresh to start..."
          sleep 15
      
      - name: Weryfikuj status Instance Refresh
        timeout-minutes: 2
        run: |
          echo "üîç Verifying instance refresh status..."
          
          MAX_ATTEMPTS=6
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS..."
            
            REFRESH_STATUS=$(aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name ${{ env.ASG_NAME }} \
              --instance-refresh-ids ${{ steps.start-refresh.outputs.REFRESH_ID }} \
              --query 'InstanceRefreshes[0].Status' \
              --output text 2>/dev/null || echo "Unknown")
            
            echo "Current status: $REFRESH_STATUS"
            
            if [ "$REFRESH_STATUS" = "Failed" ] || [ "$REFRESH_STATUS" = "Cancelled" ]; then
              echo "‚ùå Instance refresh failed or was cancelled!"
              
              # Pobierz szczeg√≥≈Çy b≈Çƒôdu
              echo "Error details:"
              aws autoscaling describe-instance-refreshes \
                --auto-scaling-group-name ${{ env.ASG_NAME }} \
                --instance-refresh-ids ${{ steps.start-refresh.outputs.REFRESH_ID }} \
                --query 'InstanceRefreshes[0].[StatusReason,PercentageComplete]' \
                --output table
              
              exit 1
            elif [ "$REFRESH_STATUS" = "InProgress" ]; then
              echo "‚úÖ Instance refresh is running successfully!"
              
              # Poka≈º progress
              PROGRESS=$(aws autoscaling describe-instance-refreshes \
                --auto-scaling-group-name ${{ env.ASG_NAME }} \
                --instance-refresh-ids ${{ steps.start-refresh.outputs.REFRESH_ID }} \
                --query 'InstanceRefreshes[0].PercentageComplete' \
                --output text)
              echo "Progress: ${PROGRESS}%"
              break
            elif [ "$REFRESH_STATUS" = "Pending" ]; then
              echo "‚è≥ Refresh is pending, waiting..."
              sleep 10
              ATTEMPT=$((ATTEMPT + 1))
            elif [ "$REFRESH_STATUS" = "Successful" ]; then
              echo "‚úÖ Instance refresh already completed!"
              break
            else
              echo "‚ö†Ô∏è  Unknown status: $REFRESH_STATUS"
              sleep 10
              ATTEMPT=$((ATTEMPT + 1))
            fi
          done
          
          if [ $ATTEMPT -gt $MAX_ATTEMPTS ]; then
            echo "‚ö†Ô∏è  Verification timed out, but refresh may still be running"
            echo "Check AWS Console for current status"
          fi
      
      - name: Status deploymentu
        run: |
          echo "‚úÖ Deployment initiated successfully!"
          echo ""
          echo "üì¶ Deployment Details:"
          echo "  Backend image: ${{ needs.build-and-push-backend.outputs.image_uri }}"
          echo "  Frontend S3: s3://${{ env.S3_BUCKET_FRONTEND }}/latest/"
          echo "  ASG: ${{ env.ASG_NAME }}"
          echo "  Instance Refresh ID: ${{ steps.start-refresh.outputs.REFRESH_ID }}"
          echo ""
          echo "üîç Monitor Progress:"
          echo "  AWS Console ‚Üí EC2 ‚Üí Auto Scaling Groups ‚Üí ${{ env.ASG_NAME }}"
          echo "  - Activity tab: Zobacz instance lifecycle events"
          echo "  - Instance refresh tab: Monitoruj progress refresh"
          echo ""
          echo "‚è±Ô∏è  Expected completion time: ~10-15 minutes"
          echo "  (Instance warmup: 5min + checkpoint delay: 5min)"

  # ============================================
  # NOTYFIKACJE (opcjonalne)
  # ============================================
  notify:
    name: Deployment Status
    runs-on: ubuntu-latest
    needs: [check-workflows, build-and-push-backend, build-and-upload-frontend, deploy]
    if: always()
    
    steps:
      - name: Deployment status
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "‚úÖ =========================================="
            echo "‚úÖ DEPLOYMENT SUCCESSFUL!"
            echo "‚úÖ =========================================="
            echo ""
            echo "Backend: ${{ needs.build-and-push-backend.outputs.image_uri }}"
            echo "Frontend: s3://${{ env.S3_BUCKET_FRONTEND }}/latest/"
            echo "Instance Refresh ID: ${{ needs.deploy.outputs.refresh_id }}"
            echo ""
            echo "Monitor at: https://console.aws.amazon.com/ec2/home?region=${{ env.AWS_REGION }}#AutoScalingGroupDetails:id=${{ env.ASG_NAME }};view=instanceRefreshes"
          else
            echo "‚ùå =========================================="
            echo "‚ùå DEPLOYMENT FAILED!"
            echo "‚ùå =========================================="
            echo ""
            echo "Check the logs above for details"
            exit 1
          fi
