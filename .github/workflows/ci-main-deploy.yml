name: CD - Main (Deployment)

on:
  workflow_run:
    workflows: 
      - "CI - Main (Security)"
      - "CI - Main (Testy)"
    types:
      - completed
    branches: [ main ]

permissions:
  id-token: write   # Wymagane dla OIDC
  contents: read    # Wymagane do checkout kodu

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY_BACKEND: forum-backend
  S3_BUCKET_FRONTEND: forum-frontend-builds-kongoapp
  ASG_NAME: forum-asg
  LAUNCH_TEMPLATE_NAME: forum-lt
  ALB_DNS: forum-alb-1684129147.us-east-1.elb.amazonaws.com

jobs:
  # ============================================
  # SPRAWD≈π CZY WSZYSTKIE WORKFLOW PRZESZ≈ÅY
  # ============================================
  check-workflows:
    name: Check Security & Tests Status
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success'
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
    
    steps:
      - name: Check if all required workflows passed
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const branch = 'main';
            
            // Pobierz ostatnie uruchomienia workflow
            const securityRuns = await github.rest.actions.listWorkflowRuns({
              owner,
              repo,
              workflow_id: 'main-security.yml',
              branch,
              per_page: 1
            });
            
            const testsRuns = await github.rest.actions.listWorkflowRuns({
              owner,
              repo,
              workflow_id: 'main-tests.yml',
              branch,
              per_page: 1
            });
            
            const securityPassed = securityRuns.data.workflow_runs[0]?.conclusion === 'success';
            const testsPassed = testsRuns.data.workflow_runs[0]?.conclusion === 'success';
            
            console.log(`Security workflow: ${securityPassed ? '‚úÖ passed' : '‚ùå failed'}`);
            console.log(`Tests workflow: ${testsPassed ? '‚úÖ passed' : '‚ùå failed'}`);
            
            if (securityPassed && testsPassed) {
              core.setOutput('should_deploy', 'true');
              console.log('‚úÖ All workflows passed - proceeding with deployment');
            } else {
              core.setOutput('should_deploy', 'false');
              core.setFailed('‚ùå Not all required workflows passed');
            }

  # ============================================
  # BUILD I PUSH DOCKER DO ECR
  # ============================================
  build-and-push-backend:
    name: Build & Push Backend to ECR
    runs-on: ubuntu-latest
    needs: check-workflows
    if: needs.check-workflows.outputs.should_deploy == 'true'
    outputs:
      image_uri: ${{ steps.build-image.outputs.image_uri }}
    
    steps:
      - name: Pobierz kod
        uses: actions/checkout@v3
      
      - name: Konfiguruj AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::311603531332:role/GitHubActionsRole
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Logowanie do Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Build, tag i push obraz do ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY_BACKEND }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          cd backend
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "image_uri=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "‚úÖ Backend image pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

  # ============================================
  # BUILD REACT I UPLOAD DO S3
  # ============================================
  build-and-upload-frontend:
    name: Build & Upload Frontend to S3
    runs-on: ubuntu-latest
    needs: check-workflows
    if: needs.check-workflows.outputs.should_deploy == 'true'
    
    steps:
      - name: Pobierz kod
        uses: actions/checkout@v3
      
      - name: Konfiguruj AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::311603531332:role/GitHubActionsRole
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Ustaw Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Utw√≥rz .env.production
        working-directory: ./frontend
        run: |
          echo "REACT_APP_API_URL=/api" > .env.production
          cat .env.production
      
      - name: Zainstaluj zale≈ºno≈õci
        working-directory: ./frontend
        run: npm ci
      
      - name: Buduj aplikacjƒô React
        working-directory: ./frontend
        run: npm run build
      
      - name: Sprawd≈∫ czy build siƒô uda≈Ç
        working-directory: ./frontend
        run: |
          test -d build && echo "‚úÖ Build successful!" || exit 1
          echo "Build size: $(du -sh build | cut -f1)"
      
      - name: Sprawd≈∫ czy S3 bucket istnieje
        run: |
          if ! aws s3 ls "s3://${{ env.S3_BUCKET_FRONTEND }}" 2>&1 | grep -q 'NoSuchBucket'; then
            echo "‚úÖ Bucket exists"
          else
            echo "‚ö†Ô∏è  Bucket doesn't exist, creating..."
            aws s3 mb "s3://${{ env.S3_BUCKET_FRONTEND }}" --region ${{ env.AWS_REGION }}
            aws s3api put-public-access-block \
              --bucket ${{ env.S3_BUCKET_FRONTEND }} \
              --public-access-block-configuration \
              "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"
          fi
      
      - name: Usu≈Ñ poprzedni build z S3
        run: |
          echo "üóëÔ∏è  Deleting old build from S3..."
          aws s3 rm "s3://${{ env.S3_BUCKET_FRONTEND }}/latest/" --recursive || echo "No old build to delete"
      
      - name: Upload nowy build do S3
        run: |
          echo "üì§ Uploading new build to S3..."
          aws s3 sync frontend/build/ "s3://${{ env.S3_BUCKET_FRONTEND }}/latest/" \
            --delete \
            --region ${{ env.AWS_REGION }} \
            --exclude ".DS_Store" \
            --exclude "*.map"
          echo "‚úÖ Upload completed!"
      
      - name: Utw√≥rz backup (opcjonalne)
        run: |
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          aws s3 sync "s3://${{ env.S3_BUCKET_FRONTEND }}/latest/" "s3://${{ env.S3_BUCKET_FRONTEND }}/backups/$TIMESTAMP/" --region ${{ env.AWS_REGION }} || echo "Backup skipped"
          echo "‚úÖ Backup created: s3://${{ env.S3_BUCKET_FRONTEND }}/backups/$TIMESTAMP/"

  # ============================================
  # UPDATE LAUNCH TEMPLATE (je≈õli potrzeba)
  # ============================================
  update-launch-template:
    name: Update Launch Template
    runs-on: ubuntu-latest
    needs: [check-workflows, build-and-push-backend, build-and-upload-frontend]
    if: needs.check-workflows.outputs.should_deploy == 'true'
    outputs:
      template_updated: ${{ steps.check-changes.outputs.CHANGED }}
    
    steps:
      - name: Pobierz kod
        uses: actions/checkout@v3
      
      - name: Konfiguruj AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::311603531332:role/GitHubActionsRole
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Pobierz Account ID i ECR URI
        id: get-ecr-info
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${{ env.ECR_REPOSITORY_BACKEND }}"
          echo "ECR_URI=$ECR_URI" >> $GITHUB_OUTPUT
          echo "ECR URI: $ECR_URI"
      
      - name: Przygotuj user-data z repo
        id: prepare-user-data
        run: |
          # U≈ºyj user-data z repo
          cp backend/user_data.txt /tmp/user-data.sh
          
          # Podmie≈Ñ dynamiczne warto≈õci
          sed -i "s|311603531332.dkr.ecr.us-east-1.amazonaws.com/forum-backend|${{ steps.get-ecr-info.outputs.ECR_URI }}|g" /tmp/user-data.sh
          
          echo "‚úÖ User-data prepared from repository"
          echo "Preview (first 20 lines):"
          head -20 /tmp/user-data.sh
      
      - name: Pobierz obecnƒÖ wersjƒô Launch Template
        id: get-current-version
        run: |
          LATEST_VERSION=$(aws ec2 describe-launch-template-versions \
            --launch-template-name ${{ env.LAUNCH_TEMPLATE_NAME }} \
            --query 'LaunchTemplateVersions[0].VersionNumber' \
            --output text)
          
          echo "LATEST_VERSION=$LATEST_VERSION" >> $GITHUB_OUTPUT
          echo "Current Launch Template version: $LATEST_VERSION"
      
      - name: Dodaj timestamp do user-data (force update)
        id: add-timestamp
        run: |
          # Dodaj timestamp jako komentarz na ko≈Ñcu user-data
          # To gwarantuje ≈ºe ka≈ºdy deployment tworzy NOWƒÑ wersjƒô Launch Template
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          COMMIT_SHA="${{ github.sha }}"
          
          echo "" >> /tmp/user-data.sh
          echo "# Deployment timestamp: $TIMESTAMP" >> /tmp/user-data.sh
          echo "# Git commit: $COMMIT_SHA" >> /tmp/user-data.sh
          echo "# Instance refresh will replace all instances" >> /tmp/user-data.sh
          
          echo "‚úÖ Timestamp added to user-data"
      
      - name: Utw√≥rz nowƒÖ wersjƒô Launch Template (zawsze)
        id: create-version
        run: |
          USER_DATA_B64=$(base64 -w 0 < /tmp/user-data.sh)
          
          echo "üìù Creating new Launch Template version..."
          NEW_VERSION=$(aws ec2 create-launch-template-version \
            --launch-template-name ${{ env.LAUNCH_TEMPLATE_NAME }} \
            --source-version ${{ steps.get-current-version.outputs.LATEST_VERSION }} \
            --launch-template-data "{\"UserData\":\"$USER_DATA_B64\"}" \
            --query 'LaunchTemplateVersion.VersionNumber' \
            --output text)
          
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "‚úÖ New Launch Template version created: $NEW_VERSION"
          echo "Previous version: ${{ steps.get-current-version.outputs.LATEST_VERSION }}"
          echo "CHANGED=true" >> $GITHUB_OUTPUT
      
      - name: Ustaw nowƒÖ wersjƒô jako domy≈õlnƒÖ
        run: |
          aws ec2 modify-launch-template \
            --launch-template-name ${{ env.LAUNCH_TEMPLATE_NAME }} \
            --default-version '$Latest' \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Launch Template version ${{ steps.create-version.outputs.NEW_VERSION }} set as default"

  # ============================================
  # DEPLOY - RESTART ASG
  # ============================================
  deploy:
    name: Deploy to EC2 (ASG Instance Refresh)
    runs-on: ubuntu-latest
    needs: [check-workflows, build-and-push-backend, build-and-upload-frontend, update-launch-template]
    if: needs.check-workflows.outputs.should_deploy == 'true'
    outputs:
      refresh_id: ${{ steps.start-refresh.outputs.REFRESH_ID }}
    
    steps:
      - name: Konfiguruj AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::311603531332:role/GitHubActionsRole
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Anuluj istniejƒÖcy Instance Refresh (je≈õli dzia≈Ça)
        id: cancel-existing
        run: |
          echo "üîç Checking for existing instance refreshes..."
          
          # Pobierz aktywne instance refreshes
          ACTIVE_REFRESHES=$(aws autoscaling describe-instance-refreshes \
            --auto-scaling-group-name ${{ env.ASG_NAME }} \
            --query 'InstanceRefreshes[?Status==`InProgress` || Status==`Pending`].InstanceRefreshId' \
            --output text)
          
          if [ -n "$ACTIVE_REFRESHES" ]; then
            echo "‚ö†Ô∏è  Found active instance refresh(es), cancelling..."
            for REFRESH_ID in $ACTIVE_REFRESHES; do
              echo "Cancelling: $REFRESH_ID"
              aws autoscaling cancel-instance-refresh \
                --auto-scaling-group-name ${{ env.ASG_NAME }} \
                --region ${{ env.AWS_REGION }} || true
            done
            
            # Poczekaj a≈º anulowanie siƒô zako≈Ñczy
            echo "‚è≥ Waiting for cancellation to complete..."
            sleep 30
          else
            echo "‚úÖ No active instance refreshes found"
          fi
      
      - name: Sprawd≈∫ Launch Template przed refresh
        id: verify-template
        run: |
          echo "üîç Verifying Launch Template configuration..."
          
          # Pobierz domy≈õlnƒÖ wersjƒô Launch Template
          DEFAULT_VERSION=$(aws ec2 describe-launch-templates \
            --launch-template-names ${{ env.LAUNCH_TEMPLATE_NAME }} \
            --query 'LaunchTemplates[0].DefaultVersionNumber' \
            --output text)
          
          echo "Default Launch Template version: $DEFAULT_VERSION"
          echo "This version will be used for new instances"
          
          # Sprawd≈∫ czy ASG u≈ºywa $Latest lub $Default
          LT_CONFIG=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names ${{ env.ASG_NAME }} \
            --query 'AutoScalingGroups[0].LaunchTemplate' \
            --output json)
          
          echo "ASG Launch Template config:"
          echo "$LT_CONFIG" | jq '.'
      
      - name: Uruchom Instance Refresh (z wymuszeniem)
        id: start-refresh
        run: |
          echo "üöÄ Starting instance refresh with forced replacement..."
          
          # KLUCZOWE ZMIANY:
          # 1. Strategy = "Rolling" (Replace instances, nie tylko root volumes)
          # 2. MinHealthyPercentage: 90, MaxHealthyPercentage: 100
          # 3. InstanceWarmup: 300 (5 minut)
          # 4. SkipMatching: true - wymusza refresh
          # 5. Desired configuration: okre≈õlamy konkretnƒÖ wersjƒô Launch Template
          
          # Pobierz najnowszƒÖ wersjƒô Launch Template
          LATEST_LT_VERSION=$(aws ec2 describe-launch-template-versions \
            --launch-template-name ${{ env.LAUNCH_TEMPLATE_NAME }} \
            --versions '$Latest' \
            --query 'LaunchTemplateVersions[0].VersionNumber' \
            --output text)
          
          echo "Will use Launch Template version: $LATEST_LT_VERSION"
          
          REFRESH_ID=$(aws autoscaling start-instance-refresh \
            --auto-scaling-group-name ${{ env.ASG_NAME }} \
            --strategy Rolling \
            --desired-configuration "{
              \"LaunchTemplate\": {
                \"LaunchTemplateName\": \"${{ env.LAUNCH_TEMPLATE_NAME }}\",
                \"Version\": \"$LATEST_LT_VERSION\"
              }
            }" \
            --preferences '{
              "MinHealthyPercentage": 90,
              "MaxHealthyPercentage": 100,
              "InstanceWarmup": 300,
              "CheckpointPercentages": [50],
              "CheckpointDelay": 300,
              "SkipMatching": false,
              "ScaleInProtectedInstances": "Ignore",
              "StandbyInstances": "Ignore"
            }' \
            --region ${{ env.AWS_REGION }} \
            --query 'InstanceRefreshId' \
            --output text 2>&1)
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Failed to start instance refresh!"
            echo "Error: $REFRESH_ID"
            
            # Sprawd≈∫ szczeg√≥≈Çy ASG
            echo ""
            echo "ASG Details:"
            aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names ${{ env.ASG_NAME }} \
              --query 'AutoScalingGroups[0].[MinSize,MaxSize,DesiredCapacity,Instances[*].[InstanceId,LaunchTemplate.Version]]' \
              --output table
            
            exit 1
          fi
          
          echo "REFRESH_ID=$REFRESH_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Instance refresh started: $REFRESH_ID"
          echo ""
          echo "Configuration:"
          echo "  - Strategy: Rolling (Replace instances)"
          echo "  - Launch Template Version: $LATEST_LT_VERSION (explicit)"
          echo "  - Min Healthy: 90%"
          echo "  - Max Healthy: 100%"
          echo "  - Instance Warmup: 300s"
          echo "  - Skip Matching: false (comparing versions)"
      
      - name: Czekaj na rozpoczƒôcie refresh
        run: |
          echo "‚è≥ Waiting for instance refresh to start..."
          sleep 15
      
      - name: Weryfikuj status Instance Refresh
        timeout-minutes: 3
        run: |
          echo "üîç Verifying instance refresh status..."
          
          MAX_ATTEMPTS=12
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo ""
            echo "Check $ATTEMPT/$MAX_ATTEMPTS..."
            
            REFRESH_INFO=$(aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name ${{ env.ASG_NAME }} \
              --instance-refresh-ids ${{ steps.start-refresh.outputs.REFRESH_ID }} \
              --query 'InstanceRefreshes[0]' \
              --output json 2>/dev/null || echo "{}")
            
            STATUS=$(echo "$REFRESH_INFO" | jq -r '.Status // "Unknown"')
            PERCENTAGE=$(echo "$REFRESH_INFO" | jq -r '.PercentageComplete // 0')
            INSTANCES_TO_UPDATE=$(echo "$REFRESH_INFO" | jq -r '.InstancesToUpdate // 0')
            
            echo "Status: $STATUS"
            echo "Progress: ${PERCENTAGE}%"
            echo "Instances to update: $INSTANCES_TO_UPDATE"
            
            # KLUCZOWA WALIDACJA: Sprawd≈∫ czy sƒÖ instancje do zaktualizowania
            if [ "$INSTANCES_TO_UPDATE" = "0" ] && [ "$STATUS" != "InProgress" ]; then
              echo ""
              echo "‚ùå ERROR: Instance refresh found 0 instances to update!"
              echo "This means AWS thinks instances are already up-to-date."
              echo ""
              echo "Troubleshooting info:"
              
              # Poka≈º obecne instancje i ich Launch Template versions
              echo ""
              echo "Current instances:"
              aws autoscaling describe-auto-scaling-groups \
                --auto-scaling-group-names ${{ env.ASG_NAME }} \
                --query 'AutoScalingGroups[0].Instances[*].[InstanceId,LaunchTemplate.Version,LaunchTemplate.LaunchTemplateName,HealthStatus]' \
                --output table
              
              # Poka≈º Launch Template versions
              echo ""
              echo "Launch Template versions:"
              aws ec2 describe-launch-template-versions \
                --launch-template-name ${{ env.LAUNCH_TEMPLATE_NAME }} \
                --max-results 3 \
                --query 'LaunchTemplateVersions[*].[VersionNumber,CreateTime,DefaultVersion]' \
                --output table
              
              echo ""
              echo "‚ö†Ô∏è  Instance refresh completed immediately with no changes."
              echo "The Launch Template update may not have propagated correctly."
              
              # Nie wychod≈∫my z b≈Çƒôdem - niech deployment siƒô uda, ale zalogujmy warning
              echo "::warning::Instance refresh updated 0 instances - check if Launch Template is correctly configured"
              break
            fi
            
            if [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ]; then
              echo ""
              echo "‚ùå Instance refresh failed or was cancelled!"
              
              # Pobierz szczeg√≥≈Çy b≈Çƒôdu
              echo "Error details:"
              echo "$REFRESH_INFO" | jq '.StatusReason // "No reason provided"'
              
              exit 1
            elif [ "$STATUS" = "InProgress" ]; then
              echo "‚úÖ Instance refresh is running successfully!"
              
              if [ "$INSTANCES_TO_UPDATE" != "0" ]; then
                echo "‚úÖ Will update $INSTANCES_TO_UPDATE instance(s)"
              fi
              
              break
            elif [ "$STATUS" = "Pending" ]; then
              echo "‚è≥ Refresh is pending, waiting..."
              sleep 15
              ATTEMPT=$((ATTEMPT + 1))
            elif [ "$STATUS" = "Successful" ]; then
              if [ "$INSTANCES_TO_UPDATE" = "0" ]; then
                echo "‚ö†Ô∏è  Refresh completed but updated 0 instances!"
                echo "::warning::Instance refresh updated 0 instances"
              else
                echo "‚úÖ Instance refresh already completed successfully!"
              fi
              break
            else
              echo "‚ö†Ô∏è  Unknown status: $STATUS"
              sleep 15
              ATTEMPT=$((ATTEMPT + 1))
            fi
          done
          
          if [ $ATTEMPT -gt $MAX_ATTEMPTS ]; then
            echo ""
            echo "‚ö†Ô∏è  Verification timed out after 3 minutes"
            echo "Instance refresh may still be starting - check AWS Console"
            echo "::warning::Instance refresh verification timed out"
          fi"
            echo "Check AWS Console for current status"
          fi
      
      - name: Status deploymentu
        run: |
          echo "‚úÖ Deployment initiated successfully!"
          echo ""
          echo "üì¶ Deployment Details:"
          echo "  Backend image: ${{ needs.build-and-push-backend.outputs.image_uri }}"
          echo "  Frontend S3: s3://${{ env.S3_BUCKET_FRONTEND }}/latest/"
          echo "  ASG: ${{ env.ASG_NAME }}"
          echo "  Instance Refresh ID: ${{ steps.start-refresh.outputs.REFRESH_ID }}"
          echo ""
          echo "üîç Monitor Progress:"
          echo "  AWS Console ‚Üí EC2 ‚Üí Auto Scaling Groups ‚Üí ${{ env.ASG_NAME }}"
          echo "  - Activity tab: Zobacz instance lifecycle events"
          echo "  - Instance refresh tab: Monitoruj progress refresh"
          echo ""
          echo "‚è±Ô∏è  Expected completion time: ~10-15 minutes"
          echo "  (Instance warmup: 5min + checkpoint delay: 5min)"

  # ============================================
  # NOTYFIKACJE 
  # ============================================
  notify:
    name: Deployment Status
    runs-on: ubuntu-latest
    needs: [check-workflows, build-and-push-backend, build-and-upload-frontend, deploy]
    if: always()
    
    steps:
      - name: Deployment status
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "‚úÖ =========================================="
            echo "‚úÖ DEPLOYMENT SUCCESSFUL!"
            echo "‚úÖ =========================================="
            echo ""
            echo "Backend: ${{ needs.build-and-push-backend.outputs.image_uri }}"
            echo "Frontend: s3://${{ env.S3_BUCKET_FRONTEND }}/latest/"
            echo "Instance Refresh ID: ${{ needs.deploy.outputs.refresh_id }}"
            echo ""
            echo "Monitor at: https://console.aws.amazon.com/ec2/home?region=${{ env.AWS_REGION }}#AutoScalingGroupDetails:id=${{ env.ASG_NAME }};view=instanceRefreshes"
          else
            echo "‚ùå =========================================="
            echo "‚ùå DEPLOYMENT FAILED!"
            echo "‚ùå =========================================="
            echo ""
            echo "Check the logs above for details"
            exit 1
          fi
